---
title: em Rem
date: 2020-03-15 12:10:10
tags:
    - css
categories: css

---
## em和rem
--------
em是最常见的相对长度单位，这是排版中使用的一种度量方式，基准值是当前元素的字号大小。 在CSS中，1em表示当前元素的字号大小，实际值取决于在哪个元素上应用.
<!-- more -->
padding为1em的元素（添加虚线是为了让padding更明显）
![](/assets/1em.png)
代码
![](/assets/1emCode.png)
把padding赋值为1em，乘以字号，得到一个值为16px的padding渲染值。重点来了，使用相对单位声明的值会由浏览器转化为一个绝对值，我们称之为计算值。

在这个例子里，将padding改为2em会生成一个32px的计算值。如果同一个元素的另一个选择器，用一个不一样的字号值去覆盖它，这会改变em在这个域下的基准值，那么padding的计算值也会相应变化。

在设置padding、height、width或border-radius等属性时，使用em可能会很方便，因为如果它们继承了不同的字号大小，或者用户更改了字体设置，这些属性会均匀地缩放。

两个不同大小的盒子。盒子内的font-size、padding和border-radius各不相同

有相对大小的padding和border-radius的元素
![](/assets/box-sl.png)
代码
![](/assets/box-slCode.png)
不同的字号大小，这会改变元素的em实际值的大小

这是em一个强大的功能。你可以定义一个元素的字号大小，然后使用一句简单的声明，就可以通过改变字号大小从而控制整个元素大小缩放。你后面将会创建另外一个这样的例子，不过首先，我们来讨论一下em和字号大小。

### 对font-size使用em

当font-size使用em作为单位时，它的表现会有点不一样。我之前说过，em是以当前元素的字号大小作为基准值的。但是，如果你把一个元素的字号设为1.2em的时候，这是什么意思呢？一个元素的字号大小是不能等于它自己的1.2倍的。相反，在font-size上的em会先从继承到的字号大小衍生出来。

举个简单的例子.以下展示了一些不同字号大小的文字。
![](/assets/fontSize.png)
代码
![](/assets/fontSizeCode.png)

slogan从继承了字号大小。
代码片段中，CSS代码片段声明了body的字号大小。为了更加清晰，在这里我用了px来声明。下一步，你可以用em来放大slogan的字号大小。
计算：这个元素继承到字号，乘以1.2
slogan声明的字号大小是1.2em，为了计算转换成像素值，你需要引用继承的字号16px，16 * 1.2 = 19.2，所以计算字号值是19.2px。

>- 提示
如果你已经知道以px为单位的基础字号大小，但希望把它改用em声明，下面有个简单的计算公式：目标em值 = 目标像素值 / 父元素（被继承元素）像素值。举个例子，如果你想要一个10px的字号大小，父元素的字号是12px，10 / 12 = 0.8333em。如果你想要16px的字号大小，父元素字号是12px，那么 16 / 12 = 1.3333em。我们会在这章里多次用到这个计算公式。

有一点对你很有帮助，对于大多数浏览器，默认字号大小是16px。技术上，关键字medium会被计算转换为16px。

### 当我们在一个元素内用em同时声明font-size和其他属性

你已经使用过em声明font-size了（基于一个继承的字号大小值）。以及，你也曾经使用em声明其他属性，如padding和border-radius（基于当前元素的字号大小值）。当你针对同一个元素使用em声明font-size和其他属性的时候，em会变得很神奇。此时浏览器必须先计算font-size，然后基于这个值再去计算其他值。这些属性声明的时候使用的是相同的em值，但很可能它们会有不同的计算值。

在之前的例子里，我们计算到字号大小是19.2px（继承的16px乘以1.2em）。相同的slogan元素，但有额外的1.2em padding以及为了让padding大小更加明显的灰色背景。可以看出，padding比font-size稍微大一些，尽管它俩声明的时候em值是一样的。
![](/assets/fsPd.png)
代码
![](/assets/fsPdCode.png)
font-size 赋值为 19.2 px
padding赋值为 23.04 px
在这个例子里，padding的声明值为1.2em，乘以19.2px（当前元素的字号大小），计算出23.04px。我们可以看到，尽管font-size和padding声明时em值是一样的，但它们的计算值是不一样的。

### 字号收缩问题
当你使用em声明多层嵌套的元素字号时，会产生意想不到的效果。要弄清楚每个元素的实际值，首先你需要知道它继承的父元素的字号大小，如果父元素的字号也是用em声明的，那么你需要知道它的父元素的字号大小，在dom树往上查，以此类推。

当你使用em声明列表的字号大小，列表嵌套了好几层，效果就更明显了。大多数web开发者会发现在他们的职业生涯里面，列表嵌套形式有点眼熟。文字在逐步缩小！正是因为em带来的这一类烦人的问题，开发者才对em避而远之。

![](/assets/ul.png)
代码
![](/assets/ulCode.png)

当你多层嵌套列表，而每一层声明的字号大小以em为单位，字号收缩现象就会发生。无序列表的字号是0.8em。这个选择器对页面上所有的ul有效，所以当一个列表从另外一个列表继承到字号大小的时候，em就产生复合效果。

这个列表嵌套在第一个列表里，继承了它的字号大小
然后这个列表又嵌套在另一个列表里，继承了第二个列表的字号大小
……以此类推
每一个列表的字号大小是0.8乘以父元素的字号大小。这代表第一个列表的字号大小是12.8px，嵌套的子列表字号大小是10.24px（12.8px * 0.8），第三层列表的是8.192px，如此类推。同样地，如果你给字号大小的赋值大于1em，相反，文字的字号会一层层变大。我们想要的效果,在顶层声明字号的大小，但下面嵌套层级的列表字号保持不变。
![](/assets/ulNor.png)
代码
![](/assets/ulNorCode.png)

嵌套在列表里面的列表，应该把字号大小设定为跟父元素一样
这可以解决问题，但不是最优方案。因为你设置了一个字号值，马上用另一个选择器重写了这个规则。如果你可以使用针对嵌套的列表声明一个特定的选择器，避免互相覆盖，会是一个更好的方案。

到现在我们清楚了，如果你不是一个比较小心的人，你应该远离em。使用em作为padding、margin和元素缩放效果的单位挺好的，但当em遇上font-size时，事情可以变得很复杂。感谢上天，我们有个更好的选择 —— rem。

### 对font-size使用rem

当浏览器解析HTML文档时，创建了一个用来代表页面元素的集合，叫做DOM（文档对象模型，Document Object Model）。树状结构，每一个节点代表一个元素。<html>就是顶层节点（根节点），在下面的是它的子节点<head>和<body>，再往下就是它们的子节点，还有后代节点，如此类推。

根节点是文档里所有其他元素的祖先。它有一个特别的伪类（pseudo-class）选择器（:root），在样式表里可以用这个选择器表示。使用带类名的类型选择器html，或者直接用标签选择器，效果是一样的。

rem是根em（root em）的缩写。rem是和根元素关联的，不依赖当前元素。不管你在文档中的什么地方使用这个单位，1.2rem的计算值是相等的，等于1.2倍的根元素的字号大小。下面的示例代码中，声明了根元素的字号大小，并在嵌套的无序列表中使用rem声明字号大小。

![](/assets/rem.png)
伪类 :root 等价于 html 选择器
使用浏览器的默认字号大小（16px）
在这个示例里，根字号大小是浏览器的默认大小16px（根元素的1em等于浏览器的默认字号大小）。无序列表的字号大小为0.8rem，计算结果是12.8px。因为这只跟根元素相关，尽管你在列表里嵌套了列表，嵌套子列表的字号仍然保持不变。

>-可用性：对font-size使用相对长度单位
一些浏览器会提供给用户2种方式定制文字的大小：缩放和设置一个默认的字号大小。通过按Ctrl+或者Ctrl-，用户可以对页面进行缩放。这在视觉上会把整个页面的文字或图片（其实是所有元素）都放大或缩小了。在一些浏览器，这个改变只针对当前的标签页且是临时的，不会影响到新开的标签页。
设置默认字号大小，会有点不一样。不仅仅是设置的入口比较难找（一般在浏览器的设置页），而且这个设置是永久的，直到用户把默认值还原。值得注意的是，这个设置对使用px或其他绝对单位定义的字号大小无效。因为默认字号大小对一些用户是必要的，尤其是弱视的群体，你应该用相对单位或百分比来定义字号的大小。

rem简化了很多em带来的复杂度。事实上，rem提供了一个在px和em间的相对单位折中解决方案，而且更易于使用。那么，是不是意味着你应该在对所有元素都使用rem，去掉其他长度单位呢？当然不是。

在CSS的世界里，这个答案通常是，看情况。rem只是你的工具箱中的其中一个。掌握CSS很重要的一点，就是学会分辨在什么场景下该使用什么工具。我的选择是，对font-size使用rem，对border使用px，对其他的度量方式如padding、margin、border-radius等使用em。然而在必要时，需要声明容器的宽度的话，我更喜欢使用百分比。

这样，字号大小就变得可预测，而当其他因素影响到元素的字号大小时，你也可以借助em去缩放元素的padding和margin。在border上使用像素是很合适的，尤其当你想要一根漂亮的线的时候。以上就是我对不同属性使用不同单位的理想方案，不过我要再次声明，这些都是工具，在某些特定场景下，利用不同的工具可能取到更好的效果。

>-提示
当你不确定的时候，对font-size使用rem，对border使用px，以及对其他大多数属性使用em。

### 停止使用像素思维去思考
把页面的根元素字号大小定义为0.625em或者62.5%，在最近几年来，这样的用法很常见，这是一种模式，或者更贴切地说，这是一种反模式。
```
html {
  font-size: .625em;
}
```

我并不推荐这种用法。这个用法把浏览器默认的字号大小16px缩小到10px。这样做的好处是简化了计算，如果设计师告诉你字号大小应该是14px，那你可以很轻易地计算出1.4rem，毕竟我们还是在使用相对单位。

一开始，这看起来很方便，但事实上这样的实现方式有两个问题。第一，强制你写了很多重复的样式代码。10px对于大多数文本来说太小了，你需要在整个页面中，来来回回地覆盖它。你会发现，自己把一段段落（<p>）的字号大小声明为1.4rem，然后又把导航（<nav>）的链接字号大小声明为1.4rem，样式代码中还有很多这样的用法。这样引入了更高的错误风险，当你需要修改时发现代码耦合程度比较高，同时也会让样式文件变大。

第二个问题是，你这么做的时候，其实你还是在用像素的思维在思考。虽然在代码里写的是1.4rem，但是在你的脑子里，其实还是想的是14px。在响应式网页开发中，你应该学会适应那些“模糊”的值。1.2em实际等于多少像素，并不重要，你只需要知道这是比继承的字号大一点点，那就足够了。而且，如果在屏幕上这不是你想要的效果，那就改吧。这是需要时间实验和试错的，但事实上，使用px的时候我们也需要这样做.

### 设置一个合理的字号默认值
先假设你想把默认字号设定为14px。把10px设定为基准值，再在页面中去覆盖它的写法，我们不推荐这种写法，相反，你应该在根元素上直接声明一个值。
在这个代码片段里，目标字号值是继承的，浏览器的默认值16px，那么14/16 = 0.875。

把下面的代码添加到一个新的样式表的最上面，我们会在这上面添加其他代码。这里设定根元素（<html>）的默认字号大小。
```
:root {                    
  font-size: 0.875em;      
}
```
或者使用 HTML 选择器
14/16（期望值px / 继承值px）等于0.875
现在，你的期望基准字号14px对整个页面的元素有效，你不需要在其他地方重新声明了。你只需要在设计不一样的地方修改成新的字号，譬如标题。

你创建的这个面板，基于14px字号，使用相对单位
![](/assets/panel.png)
对padding和border-radius使用em
用1px定义细边框
把面板上面多余的空间去掉，更多解释看第3章
用rem控制标题的字号大小
这段代码给面板添加了一个细边框以及定义了标题的样式。我希望标题的字号小一点，但要加粗和全是大写。（你可以根据自己的设计，把字号改大点或者使用不同的排版方式）

第二个选择器>是一个直接后代组合选择符（direct descendant combinator），它代表的是.panel下的子元素h2。

在代码片段，为了更清晰看到效果，我给body添加了一个类panel-body，不过你会发现，在你自己的代码里是不需要的。因为这个元素从根元素上继承了字号大小，它已经是你想要看到的那样。

### 让这个面板变得“响应式”
我们再更深入地看看这个问题。你可以根据屏幕尺寸的变化，添加媒体查询来改变基础字号大小，这可以令面板在不同尺寸的屏幕下，有不同的大小变化

```
:root {                           
  font-size: 0.75em;               
}                                  

@media (min-width: 800px) {        
  :root {                          
    font-size: 0.875em;            
  }                                
}                                  

@media (min-width: 1200px) {       
  :root {                          
    font-size: 1em;                
  }                                
}
```
>-媒体查询（media query） —— 通过@media规则来声明样式，在不同的屏幕尺寸或者媒体类型（如打印机或显示器）下，触发对应的样式控制。这是响应式设计的关键要素。
针对所有屏幕，但是在更大的屏幕会被覆盖
针对比800px更宽的屏幕，覆盖默认样式代码
针对比1200px更宽的屏幕，覆盖以上两套样式代码
第一套样式规则，声明了小屏幕中的默认字号大小，这是我们想要在较小的屏幕上看到的字号大小。然后使用媒体查询，把800px和1200px分别作为两个分水岭逐级增加字号的大小，覆盖掉默认的代码。

针对页面的根元素使用这些字号大小，响应式地重新定义em和rem对应的值，从而达到响应改变整个页面的效果。尽管你没有直接对这个面板做任何的修改，它现在是响应式的。在小屏幕上，譬如一台手机，字号大小会被渲染成更小的（12px）。然后，在更大的屏幕上，宽大于800px和大于1200px的，组件的字号会分别放大到14px和16px。改变你的浏览器窗口，看看组件是怎么变化的吧。

如果你在整个页面中像这样严格使用相对单位，整个页面会随着视窗大小放大和缩小。这会是你的响应式策略里很重要的一部分。上面的2套媒体查询声明代码，可以帮助你节省在页面的其他部分使用媒体查询的额外代码。不过，如果你在元素中声明的字号大小是以像素为单位的，那就不会产生任何效果了。

类似地，如果你的老板或者客户觉得现在网站的字号太小或者太大，你随时可以做到通过修改一行代码影响到全局的元素，这项改变会影响到页面上的其他元素，不费吹灰之力。

### 调整单个组件的大小

你也可以通过使用em缩放页面上的一个独立组件。有时，你可能会需要界面上的某些组件可以有个大号的版本。在我们的面板上这么做吧，首先你需要给面板添加一个类名large：<div class="panel large">。
![](/assets/panellarge.png)
我们看到了面板的普通版和大号版的比较。效果类似响应式面板，但是两种尺寸是可以同时在同一个页面中使用的。


组合选择器指向同时有panel类和large类的元素
现在，你可以给普通面板添加class="panel"和给大号面板添加class="panel large"。类似地，你也可以定义一个小号版本，只需要把父元素的字号设得比1rem小。如果这个面板是一个更复杂的组件，包含多种字号大小或padding，也只需要一个声明就可以重置大小，只要所有的子元素都是使用em声明的。

### 视口相关单位
你已经学完em和rem了，它们都是以font-size为基准值的，但相对单位不只它们。还有视口相关单位，依赖浏览器的视口大小来定义长度的。
>-视口（viewport） —— 在浏览器窗口中用来渲染页面的可视区域，这不包括浏览器的地址栏、工具栏、状态栏等（如果有的话）。

如果你不熟悉视口相关单位的话，在这里简单介绍一下。

vh —— 视口高度的1/100
vw —— 视口宽度的1/100
vmin —— 视区宽度或高度较小值的1/100（IE9支持的是vm）
vmax —— 视区宽度或高度较大值的1/100（在写本书时，IE或者Edge都不支持）
举个例子，50vw等于视口宽度的一半，而25vh等于视口高度的25%。vmin依赖两者（宽或高）的较小值，如果我们需要确保一个元素不管在横屏还是竖屏下适应屏幕展示的话，这个属性会很有帮助：如果是横屏，vmin的基准值是屏幕的高度，如果是竖屏，它的基准值是屏幕的宽度

### 在font-size上使用vw
一个应用如果使用了视口相关单位，可能效果最不明显的地方就是用在字号大小上。事实上，我发现把vh和vw用在字号上比元素的宽或者高更实用。

试想一下，如果把元素的font-size声明为2vm，会怎么样？台式机屏幕宽是1200px，2vm等于24px（1200 * 2%）。而平板电脑的屏幕宽768px，2vm约等于15px（768 * 2%）。很棒的是，元素在两个尺寸下缩放自如。这意味着这里并没有一个突然的断点，元素会随着视口尺寸的增大而平滑增大。

不幸的是，24px对于大屏幕来说有点太大了。而更糟糕的是，在iPhone6它直接缩小到7.5px。好消息是缩放生效了，而坏消息是极限情况的处理有点差。你可以通过CSS的方法calc()解决这个问题。

### 在font-size上使用calc()
calc()函数支持对2个或者更多个数值进行基础的运算。这个函数对不同类型的单位间的运算尤其有用。这个函数支持加（+）、减（-）、乘（*）和除以（/）。其中，加和减运算符左右必须留有空格，所以我建议我们来培养一个习惯，总是在四个运算符的两侧都写上空格，譬如calc(1em + 10px)。

你会在下一个代码片段中，使用calc()来计算vh单位和em单位的值。把你的样式表中的上一段设定基础字号大小的代码去掉（及相关的媒体查询代码），添加以下代码。

[ 代码片段 2.19 在font-size中使用em和vh单位进行calc()运算 ]

:root {
  font-size: calc(0.5em + 1vw);
}
现在，打开页面，缓慢地改变浏览器的大小。你会发现，字号改变的过渡很平滑。0.5em在这里代表的是字号的最小值，1vm则代表着响应式地往上累加。这样基础字号大小就在iPhone6的11.75px和1200px宽浏览器窗口的20px间缩放。你可以根据自己的喜好改变这些值。

你现在可以实现响应式策略的核心逻辑而不需要添加一行媒体查询的代码。页面上的所有元素可以根据视口大小平滑缩放，不再需要3或4个硬编码的断点。

### 不带单位的数字（unitless number）和行高（line-height）
line-height属性最特别的地方，在于同时支持带单位和不带单位的值。你应该保持使用不带单位的数值，因为这样就可以从父元素继承。我们在页面上写点文字，看看它是怎么表现的吧。把下面代码添加到你的样式表。

```
<body>
  <p class="about-us">
    We have built partnerships with small farms around the world to
    hand-select beans at the peak of season. We then carefully roast in
    small batches to maximize their potential.
  </p>
</body>
```
给body声明一个line-height，然后文档的其他元素会从这里继承。页面的展示符合预期，不管你对页面的其他元素的字号大小做了什么改变。
对line-height使用不带单位的值
```
body {
  line-height: 1.2;               
}

.about-us {
  font-size: 2em;
}
```
后代元素继承不带单位的值
把代码内容添加到你的样式表。段落（<p>）继承了1.2的行高。因为字号是32px（2em * 16px，浏览器默认字号大小），所以本地的行高计算值是38.4px（32px * 1.2）。这会给段落的行间距留下比较合适的空间。


如果你给行高设定了一个带单位的值，你可能会得到意想不到的结果，行间文字互相重叠了，代码片段是造成这个结果的CSS代码。

```
body {
  line-height: 1.2em;             
}

.about-us {
  font-size: 2em;                 
} 
```
后代元素继承了计算值（19.2px）
等于32px

这样的结果源于一次奇怪的继承：当一个元素是用带单位的值声明的，那么它的后代元素会继承计算结果值。当行高属性是用类似em来声明时，它的值会先被计算，然后计算后的值会传到任何继承它的后代元素。对于line-height这个属性来说，如果子元素有跟父元素不一样字号大小的情况，就会导致意想不到的结果，譬如文字间的遮挡。

长度 —— CSS中用来描述距离测量的正式用语。它是一个带单位的数字，如5px。长度有两种类型：绝对的和相对的。百分比跟长度很类似，但严格来说，百分比不能叫长度。

当你（对某个属性）使用不带单位的数字，声明的值会被继承，也就是说这个值会在子元素中用来重新计算子元素域下的值，而这个通常是你想要的效果。使用不带单位的数字，可以让你在body上设定一个行高，然后什么都不用管，页面上其他元素会默认继承，除非在某个特定的地方你想要做一个额外的样式。

### CSS自定义属性 —
https://zhuanlan.zhihu.com/p/40990723