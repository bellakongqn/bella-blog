---
title: leetCode
tags:
    - js
categories: js
---

### 反转整数 123->321  -123->-321 10.21
利用数组反转的特性 reverse()
1.将整数转化为数组 
  arr= x.toString().split('') 
  123 => "123" =>["1","2","3"] 
  -123=>"-123"=>["-","1","2","3"]
2.判断数组正负 
  x<0 数组去头反转
  x>0 正常反转
3.进行反转->转换为数字
  x<0  ans = Number(arr.shift().reverse().join('')) 
  x>0  ans = Number(arr.reverse().join(''))
4.判断反转后的数字是否仍在整数范围 : 
  负值: - (1 << 30) * 2  正值:(1 << 30) * 2 - 1
  超出范围则返回0
  未超出范围则判断原值正负 x>0 ans x<0 -ans

### 判断一个数是否为回文数 101=101 √  201≠102 × 10.22
1.数字->字符串 a.toString()
2.数字->字符串->数组->反转->字符串 a.toString().split('').reverse().join("")
3.判断两个字符串是否相等

### 罗马数字转整数 IVVVV=19=(5-1)+5+5+5=19
1.避免使用switch来判断赋值，首先使用一个对象将罗马数字对应的值存储起来 hash['I']=1;
2.对罗马数字进行遍历（一般情况下大数在前，小数在后，当小数在前大数在后时，需要用大数减去小数）：
  首先判断当前是不是为最后一个数字
  是：后一个数则为0
  否：判断后一个数是否大于前一个数
     是：用大数减去小数，计算出当下数组的和，🐖：并循环+1  sum+=nextItem-item; i++;
     否：加上当下的数字；循环不用+1 sum+=item;

### 最长公共前缀 ["flower","flow","flight"]->"fl"
1.首先判断数组是否为空 如果为空 则最长公共前缀为"",不为空再进行下列操作
2.找出字符串数组中的最短字符串长度 采用数组的reduce方法
  var minLen = strs.reduce(function( pre , item ){
    return Math.min(pre, item.length)
  },Number.MAX_VALUE)
  pre->前一个返回值或者初始值
  Number.MAX_VALUE->表示js中的最大数，这里表示初始值，用来取第一个字符串长度
3.遍历字符串数组，取第一个字符串的第一个字符，判断是否每一个字符串第一个字符均为它，采用数组的every()方法
```
  for(var i=0;i<minLen;i++){
     var s=strs[0][i]
     var f = strs.every(function(item){
        return item[i]===s;
     })
     if(f){
          ans+=s;
     }else{
          break;
     }
  }
```
### 有效的括号[{([)}]=>false ()=>true 栈(后进先出) push() pop() peek()
1.先将括号之间的管理用对象存储 target['('] = ')'
2.循环字符串
3.初始化一个空数组a
  a为空:将字符串数组的元素存入a,跳出本次循环 a['(']
  a不为空:判断字符串数组中的本次值,是否于上一个值对应 s[i] === target[sta[sta.length - 1]
    相等:去除a的最后一项 a.pop()
    不想等:将本次值存入a a['(','{']
 
### 合并两个有序链表 1->2->4, 1->3->4 ==> 1->1->2->3->4->4 10.23
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
*/
1.将两个链表数存入数组 a.push(new ListNode(l1.value)); l1=l1.next
2.将数组进行排序 a.sort()
3.输入链表 a[0]

### 原地删除排序数组中的重复项 o(1) [1,1,2] 修改结束返回新的长度2，并且原数组的前两个元素被修改为1，2=》[1,2,2]
1.从数组末位开始遍历数组，定义一个数纪录数组长度 ans=0 如果当前为数组最后一项：ans+1;
  //从末位开始原因是因为会原地删除数组元素，导致数组长度改变
2.判断当前项是否后一项相等
  是：数组splice(i,1) 删除当前项
  否：数组长度+1 ans+1
3.返回数组长度数字
    [1,1,2] i=3 
    for (var i = nums.length; i--; ) {
      // 判断i--是否为true;i-1=2
      // i-1=0是条件为false
      // 循环里i=2
    }
    等价于
    for (var i = nums.length-1; i>=0; i--) {

    }

### 移除元素 原地移除所有数值等于 val 的元素，返回移除后数组的新长度。nums = [3,2,2,3], val = 3,=》[2,2]
1.从后开始遍历数组，定义数组长度 ans=0
2.判断元素是否与给定值相等
  相等：删除元素-》nums.splice(i,1)
  不相等： 数组长度+1=》ans+1

### 实现strStr() 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1 haystack = "hello", needle = "ll" 输出: 2
1.使用字符串的indexOf方法  var s= haystack.indexOf(needle) 存在返回开始位置;不存在返回-1;空字符串返回0
2.或者使用search()方法 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串

### 搜索插入位置 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 [1,3,5,6], 5=》2  [1,3,5,6], 7=》4
1.判断数组中是否包含该元素 indexOf 包含返回位置，不包含返回-1
2.若返回-1,是否小于第一项 return 0;|是否大于最后一项 return nums.length
3.遍历数组 target>nums[i]&&target<nums[i+1] =>return i+1

### 报数序列是一个整数序列，按照其中的整数的顺序进行报数 4-》1211 10.24

### 最大子序和 找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 [-2,1,-3,4,-1,2,1,-5,4]->6

### 给定一个仅包含大小写字母和空格 ' ' 的字符串，返回其最后一个单词的长度
1.将字符串根据空格进行分隔 s.split(" ")=》["hello","world"]
2.判断最后数组最后一个是否为单词 
  否：返回0；
  是：返回字符串长度

错误❌：当最后一个单词后面+空格时 导致错误
1.将字符串去除所有空格，然后将原有空格用空格代替（采用正则），然后转换成数组 
  trim()  s.replace(/\s/g, " "); split(" ")
2.判断处理后数组是否为空数组 是返回0
3.否：返回最后一个单词长度

### 加一 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一 [1,2,3]=》[1,2,4]
1.将数组最后一项替换成+1 ❌：9+1=10,需要放两个位置存储
2.将数组转换成数字+1再转换成数组 ❌：超出整数范围
3.~是按位取反
